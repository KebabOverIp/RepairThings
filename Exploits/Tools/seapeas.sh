#!/bin/bash

#################################################################
#  SEAPEAS - Docker Container Escape Enumeration Script        #
#  Inspired by LinPEAS - For authorized pentesting only        #
#################################################################

VERSION="1.0"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color
BOLD='\033[1m'

# Symbols
CHECK="[+]"
WARN="[!]"
INFO="[*]"
VULN="[!!!]"

print_banner() {
    echo -e "${CYAN}"
    cat << "EOF"
   _____ ______          _____  _____          _____ 
  / ____|  ____|   /\   |  __ \|  __ \   /\   / ____|
 | (___ | |__     /  \  | |__) | |__) | /  \ | (___  
  \___ \|  __|   / /\ \ |  ___/|  _  / / /\ \ \___ \ 
  ____) | |____ / ____ \| |    | | \ \/ ____ \____) |
 |_____/|______/_/    \_\_|    |_|  \_/_/    \_\____/ 
                                                       
    Docker Container Escape Enumeration Script
                Version: v1.0
        For authorized pentesting only!
EOF
    echo -e "${NC}"
}

print_section() {
    echo -e "\n${BOLD}${BLUE}═══════════════════════════════════════════════════════════${NC}"
    echo -e "${BOLD}${BLUE}$1${NC}"
    echo -e "${BOLD}${BLUE}═══════════════════════════════════════════════════════════${NC}\n"
}

print_subsection() {
    echo -e "\n${CYAN}${BOLD}[+] $1${NC}"
}

print_finding() {
    local level=$1
    local message=$2
    case $level in
        "critical")
            echo -e "${RED}${BOLD}${VULN} CRITICAL: $message${NC}"
            ;;
        "high")
            echo -e "${RED}${WARN} HIGH: $message${NC}"
            ;;
        "medium")
            echo -e "${YELLOW}${WARN} MEDIUM: $message${NC}"
            ;;
        "info")
            echo -e "${GREEN}${INFO} INFO: $message${NC}"
            ;;
    esac
}

check_docker_env() {
    print_section "DOCKER ENVIRONMENT DETECTION"
    
    print_subsection "Checking if running in Docker"
    if [ -f "/.dockerenv" ]; then
        print_finding "info" "/.dockerenv file found - Definitely in a Docker container"
    else
        print_finding "info" "/.dockerenv not found - checking other indicators"
    fi
    
    if grep -q docker /proc/1/cgroup 2>/dev/null; then
        print_finding "info" "Docker cgroup detected in /proc/1/cgroup"
    fi
    
    echo -e "\n${INFO} Container ID:"
    cat /proc/self/cgroup 2>/dev/null | grep -o -E '[0-9a-f]{64}' | head -n 1
}

check_privileged_mode() {
    print_section "PRIVILEGED MODE CHECK"
    
    print_subsection "Checking for privileged mode"
    
    if [ -c /dev/kmsg ]; then
        print_finding "critical" "Container is running in PRIVILEGED MODE!"
        print_finding "critical" "You can mount host filesystem and escape!"
        echo -e "${YELLOW}Exploitation:${NC}"
        echo "  mkdir /mnt/host"
        echo "  mount /dev/sda1 /mnt/host"
        echo "  chroot /mnt/host"
    else
        print_finding "info" "Container is NOT in privileged mode"
    fi
    
    # Check for full device access
    echo -e "\n${INFO} Available block devices:"
    ls -la /dev/ | grep -E "^b" 2>/dev/null
    
    if ls -la /dev/sd* 2>/dev/null | grep -q "^b"; then
        print_finding "high" "Block devices (sd*) accessible - possible escape vector!"
    fi
}

check_capabilities() {
    print_section "CAPABILITIES ANALYSIS"
    
    print_subsection "Current capabilities"
    
    if command -v capsh >/dev/null 2>&1; then
        echo -e "${INFO} Full capability list:"
        capsh --print 2>/dev/null
        
        echo -e "\n${INFO} Dangerous capabilities check:"
        
        if capsh --print 2>/dev/null | grep -q "cap_sys_admin"; then
            if ! capsh --print 2>/dev/null | grep "cap_sys_admin" | grep -q "!cap_sys_admin"; then
                print_finding "critical" "CAP_SYS_ADMIN is enabled! Container escape possible!"
                echo -e "${YELLOW}Exploitation:${NC} Can mount host filesystem"
            fi
        fi
        
        if capsh --print 2>/dev/null | grep -q "cap_sys_module"; then
            if ! capsh --print 2>/dev/null | grep "cap_sys_module" | grep -q "!cap_sys_module"; then
                print_finding "critical" "CAP_SYS_MODULE is enabled! Can load kernel modules!"
            fi
        fi
        
        if capsh --print 2>/dev/null | grep -q "cap_sys_ptrace"; then
            if ! capsh --print 2>/dev/null | grep "cap_sys_ptrace" | grep -q "!cap_sys_ptrace"; then
                print_finding "high" "CAP_SYS_PTRACE is enabled! Can debug host processes!"
            fi
        fi
        
        if capsh --print 2>/dev/null | grep -q "cap_dac_read_search"; then
            if ! capsh --print 2>/dev/null | grep "cap_dac_read_search" | grep -q "!cap_dac_read_search"; then
                print_finding "high" "CAP_DAC_READ_SEARCH is enabled! Can bypass file read permission checks!"
            fi
        fi
        
        if capsh --print 2>/dev/null | grep -q "cap_sys_rawio"; then
            if ! capsh --print 2>/dev/null | grep "cap_sys_rawio" | grep -q "!cap_sys_rawio"; then
                print_finding "critical" "CAP_SYS_RAWIO is enabled! Direct I/O operations possible!"
            fi
        fi
    else
        print_finding "info" "capsh not available, checking /proc/self/status"
        cat /proc/self/status | grep Cap
    fi
}

check_docker_socket() {
    print_section "DOCKER SOCKET CHECK"
    
    print_subsection "Checking for Docker socket"
    
    if [ -S "/var/run/docker.sock" ]; then
        print_finding "critical" "DOCKER SOCKET FOUND at /var/run/docker.sock!"
        print_finding "critical" "This is a CRITICAL vulnerability - full host access possible!"
        
        ls -la /var/run/docker.sock
        
        echo -e "\n${YELLOW}Exploitation:${NC}"
        echo "  # If docker client is available:"
        echo "  docker run -v /:/host -it ubuntu chroot /host /bin/bash"
        echo ""
        echo "  # Or install docker client:"
        echo "  curl -fsSL https://get.docker.com -o get-docker.sh && sh get-docker.sh"
        
        # Check if docker command is available
        if command -v docker >/dev/null 2>&1; then
            print_finding "critical" "Docker client is INSTALLED! Can control host Docker!"
            echo -e "\n${INFO} Docker version:"
            docker version 2>/dev/null || echo "Cannot connect to Docker daemon"
            
            echo -e "\n${INFO} Available containers:"
            docker ps -a 2>/dev/null || echo "Cannot list containers"
        fi
    else
        print_finding "info" "Docker socket not found at standard location"
    fi
    
    # Check for other socket locations
    find / -name "*.sock" -type s 2>/dev/null | while read sock; do
        if echo "$sock" | grep -qi docker; then
            print_finding "high" "Found Docker-related socket: $sock"
        fi
    done
}

check_volume_mounts() {
    print_section "VOLUME MOUNTS ANALYSIS"
    
    print_subsection "Checking for sensitive host mounts"
    
    echo -e "${INFO} All mounts:"
    mount | grep -v "^overlay\|^proc\|^tmpfs\|^devpts\|^sysfs\|^cgroup\|^mqueue\|^shm"
    
    echo -e "\n${INFO} Disk usage:"
    df -h | grep -v "^overlay\|^tmpfs\|^devpts\|^sysfs\|^cgroup\|^mqueue\|^shm"
    
    # Check for dangerous mounts
    if mount | grep -qE "/ |/host|/mnt"; then
        print_finding "critical" "Potential host filesystem mount detected!"
    fi
    
    # Check root directory for suspicious mounts
    echo -e "\n${INFO} Root directory listing:"
    ls -la / 2>/dev/null | grep -v "^d.*\.$"
    
    # Check for host paths
    for path in /host /hostfs /rootfs /mnt/host; do
        if [ -d "$path" ]; then
            print_finding "high" "Suspicious directory found: $path"
            ls -la "$path" 2>/dev/null | head -n 10
        fi
    done
}

check_namespace_isolation() {
    print_section "NAMESPACE ISOLATION"
    
    print_subsection "Checking namespace isolation"
    
    echo -e "${INFO} Process 1 namespaces:"
    ls -la /proc/1/ns/ 2>/dev/null
    
    echo -e "\n${INFO} Current process namespaces:"
    ls -la /proc/self/ns/ 2>/dev/null
    
    # Compare namespaces
    if [ "$(readlink /proc/1/ns/pid)" = "$(readlink /proc/self/ns/pid)" ]; then
        print_finding "critical" "PID namespace is NOT isolated - sharing with host!"
    fi
    
    if [ "$(readlink /proc/1/ns/net)" = "$(readlink /proc/self/ns/net)" ]; then
        print_finding "critical" "Network namespace is NOT isolated - sharing with host!"
    fi
    
    if [ "$(readlink /proc/1/ns/mnt)" = "$(readlink /proc/self/ns/mnt)" ]; then
        print_finding "critical" "Mount namespace is NOT isolated - sharing with host!"
    fi
}

check_security_modules() {
    print_section "SECURITY MODULES"
    
    print_subsection "AppArmor status"
    if [ -f "/proc/self/attr/current" ]; then
        apparmor_status=$(cat /proc/self/attr/current 2>/dev/null)
        echo -e "${INFO} AppArmor profile: $apparmor_status"
        
        if [ "$apparmor_status" = "unconfined" ]; then
            print_finding "medium" "Container is UNCONFINED by AppArmor"
        fi
    fi
    
    if command -v aa-status >/dev/null 2>&1; then
        aa-status 2>/dev/null
    fi
    
    print_subsection "SELinux status"
    if [ -f "/sys/fs/selinux/enforce" ]; then
        selinux_status=$(cat /sys/fs/selinux/enforce 2>/dev/null)
        if [ "$selinux_status" = "0" ]; then
            print_finding "medium" "SELinux is in PERMISSIVE mode"
        else
            print_finding "info" "SELinux is enforcing"
        fi
    else
        print_finding "info" "SELinux not active"
    fi
    
    print_subsection "Seccomp status"
    if grep -q Seccomp /proc/self/status 2>/dev/null; then
        seccomp=$(grep Seccomp /proc/self/status)
        echo -e "${INFO} $seccomp"
        
        if echo "$seccomp" | grep -q "Seccomp:[[:space:]]*0"; then
            print_finding "high" "Seccomp is DISABLED!"
        fi
    fi
}

check_cgroups() {
    print_section "CGROUPS ANALYSIS"
    
    print_subsection "Cgroup information"
    
    echo -e "${INFO} Current cgroups:"
    cat /proc/self/cgroup 2>/dev/null
    
    echo -e "\n${INFO} Cgroup mount points:"
    mount | grep cgroup
    
    # Check for writable cgroup paths
    echo -e "\n${INFO} Checking cgroup write permissions:"
    for cgroup in /sys/fs/cgroup/*; do
        if [ -w "$cgroup" ]; then
            print_finding "high" "Writable cgroup found: $cgroup"
        fi
    done
    
    # Check for release_agent (classic escape vector)
    if [ -f "/sys/fs/cgroup/release_agent" ]; then
        if [ -w "/sys/fs/cgroup/release_agent" ]; then
            print_finding "critical" "release_agent is WRITABLE - classic escape vector!"
            echo -e "${YELLOW}Exploitation:${NC} Can use release_agent escape technique"
        fi
    fi
}

check_kernel_exploits() {
    print_section "KERNEL VERSION & KNOWN EXPLOITS"
    
    print_subsection "Kernel information"
    
    echo -e "${INFO} Kernel version:"
    uname -a
    
    echo -e "\n${INFO} OS information:"
    cat /etc/os-release 2>/dev/null || cat /etc/issue 2>/dev/null
    
    kernel_version=$(uname -r)
    
    echo -e "\n${WARN} Check these kernel versions for known exploits:"
    echo "  - DirtyCow (CVE-2016-5195): Kernel < 4.8.3"
    echo "  - DirtyPipe (CVE-2022-0847): Kernel 5.8 - 5.16.11, 5.15.x - 5.15.25, 5.10.x - 5.10.102"
    echo "  - OverlayFS (CVE-2021-3493): Ubuntu kernels"
    echo "  - Netfilter (CVE-2021-22555): Kernel < 5.11.15"
    
    echo -e "\n${INFO} Current kernel: $kernel_version"
}

check_network_info() {
    print_section "NETWORK INFORMATION"
    
    print_subsection "Network configuration"
    
    echo -e "${INFO} IP addresses:"
    ip addr 2>/dev/null || ifconfig 2>/dev/null
    
    echo -e "\n${INFO} Routing table:"
    ip route 2>/dev/null || route -n 2>/dev/null
    
    echo -e "\n${INFO} Network namespaces:"
    ls -la /var/run/netns/ 2>/dev/null
    
    echo -e "\n${INFO} Listening ports:"
    netstat -tlnp 2>/dev/null || ss -tlnp 2>/dev/null
    
    echo -e "\n${INFO} ARP table:"
    ip neigh 2>/dev/null || arp -a 2>/dev/null
}

check_processes() {
    print_section "PROCESS INFORMATION"
    
    print_subsection "Running processes"
    
    echo -e "${INFO} Process tree:"
    ps auxf 2>/dev/null || ps aux 2>/dev/null
    
    echo -e "\n${INFO} Process 1 information:"
    ls -la /proc/1/exe 2>/dev/null
    cat /proc/1/cmdline 2>/dev/null | tr '\0' ' '
    echo ""
}

check_file_permissions() {
    print_section "FILE PERMISSIONS & INTERESTING FILES"
    
    print_subsection "SUID/SGID files"
    
    echo -e "${INFO} Searching for SUID/SGID files (this may take a while)..."
    find / -type f \( -perm -4000 -o -perm -2000 \) -ls 2>/dev/null | head -n 20
    
    print_subsection "Writable directories"
    
    echo -e "${INFO} World-writable directories in /:"
    find / -maxdepth 3 -type d -writable 2>/dev/null | grep -v "^/proc\|^/sys\|^/dev" | head -n 10
    
    print_subsection "Interesting files"
    
    echo -e "${INFO} Looking for interesting files..."
    
    # SSH keys
    find / -name "id_rsa" -o -name "id_dsa" -o -name "authorized_keys" 2>/dev/null | head -n 10
    
    # Docker related files
    find / -name "*docker*" -type f 2>/dev/null | grep -v "/proc\|/sys" | head -n 10
    
    # Configuration files
    find / -name "*.conf" -o -name "*.cfg" -o -name "*.yaml" -o -name "*.yml" 2>/dev/null | grep -E "(docker|kube)" | head -n 10
}

check_environment_variables() {
    print_section "ENVIRONMENT VARIABLES"
    
    print_subsection "Current environment"
    
    echo -e "${INFO} All environment variables:"
    env | sort
    
    echo -e "\n${INFO} Docker-related variables:"
    env | grep -i docker
    
    echo -e "\n${INFO} Kubernetes-related variables:"
    env | grep -i kube
    
    # Check for secrets in environment
    if env | grep -qE "(PASSWORD|SECRET|KEY|TOKEN)" | grep -v "SSH"; then
        print_finding "medium" "Potential secrets found in environment variables!"
        env | grep -E "(PASSWORD|SECRET|KEY|TOKEN)" | grep -v "SSH"
    fi
}

check_runc_exploits() {
    print_section "RUNC VULNERABILITIES"
    
    print_subsection "Checking for known runc exploits"
    
    if command -v runc >/dev/null 2>&1; then
        runc_version=$(runc --version 2>/dev/null | head -n 1)
        echo -e "${INFO} runc version: $runc_version"
        
        echo -e "\n${WARN} Known runc vulnerabilities:"
        echo "  - CVE-2019-5736: runc < 1.0-rc6 - Container breakout"
        echo "  - CVE-2024-21626: runc < 1.1.12 - File descriptor leak"
    else
        print_finding "info" "runc command not available in container"
    fi
}

check_cloud_metadata() {
    print_section "CLOUD METADATA SERVICES"
    
    print_subsection "Checking cloud metadata endpoints"
    
    # AWS
    echo -e "${INFO} Checking AWS metadata (169.254.169.254)..."
    if timeout 2 curl -s http://169.254.169.254/latest/meta-data/ >/dev/null 2>&1; then
        print_finding "high" "AWS metadata service accessible!"
        echo "  Try: curl http://169.254.169.254/latest/meta-data/"
    fi
    
    # GCP
    echo -e "${INFO} Checking GCP metadata..."
    if timeout 2 curl -s -H "Metadata-Flavor: Google" http://metadata.google.internal/computeMetadata/v1/ >/dev/null 2>&1; then
        print_finding "high" "GCP metadata service accessible!"
        echo "  Try: curl -H 'Metadata-Flavor: Google' http://metadata.google.internal/computeMetadata/v1/"
    fi
    
    # Azure
    echo -e "${INFO} Checking Azure metadata..."
    if timeout 2 curl -s -H "Metadata: true" http://169.254.169.254/metadata/instance?api-version=2021-02-01 >/dev/null 2>&1; then
        print_finding "high" "Azure metadata service accessible!"
        echo "  Try: curl -H 'Metadata: true' http://169.254.169.254/metadata/instance?api-version=2021-02-01"
    fi
}

generate_summary() {
    print_section "SUMMARY & RECOMMENDATIONS"
    
    echo -e "${BOLD}${CYAN}Key Findings:${NC}"
    echo -e "${INFO} Review all CRITICAL and HIGH findings above"
    echo -e "${INFO} Prioritize Docker socket and privileged mode checks"
    echo -e "${INFO} Check for dangerous capabilities (CAP_SYS_ADMIN, CAP_SYS_MODULE)"
    echo -e "${INFO} Look for host filesystem mounts"
    echo -e "${INFO} Investigate kernel version for known exploits"
    
    echo -e "\n${BOLD}${CYAN}Common Escape Techniques:${NC}"
    echo -e "${INFO} 1. Privileged container + device mount"
    echo -e "${INFO} 2. Docker socket exposure"
    echo -e "${INFO} 3. Dangerous capabilities (especially CAP_SYS_ADMIN)"
    echo -e "${INFO} 4. Host filesystem mounts"
    echo -e "${INFO} 5. Cgroup release_agent exploitation"
    echo -e "${INFO} 6. Kernel vulnerabilities (DirtyCow, DirtyPipe, etc.)"
    echo -e "${INFO} 7. runc vulnerabilities (CVE-2019-5736)"
    
    echo -e "\n${BOLD}${YELLOW}⚠️  LEGAL DISCLAIMER:${NC}"
    echo -e "${YELLOW}This tool is for authorized security testing only.${NC}"
    echo -e "${YELLOW}Unauthorized access to computer systems is illegal.${NC}"
    echo -e "${YELLOW}Always obtain proper authorization before testing.${NC}"
}

# Main execution
main() {
    print_banner
    
    echo -e "${INFO} Starting SEAPEAS enumeration..."
    echo -e "${INFO} Date: $(date)"
    echo -e "${INFO} User: $(whoami)"
    echo -e "${INFO} UID: $(id -u)"
    
    check_docker_env
    check_privileged_mode
    check_capabilities
    check_docker_socket
    check_volume_mounts
    check_namespace_isolation
    check_security_modules
    check_cgroups
    check_kernel_exploits
    check_network_info
    check_processes
    check_file_permissions
    check_environment_variables
    check_runc_exploits
    check_cloud_metadata
    generate_summary
    
    echo -e "\n${GREEN}${BOLD}[✓] SEAPEAS scan completed!${NC}"
    echo -e "${INFO} Review the findings above for potential escape vectors.\n"
}

# Run the script
main "$@"
